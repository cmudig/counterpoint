<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Counterpoint Performance Evaluation</title>
    <script
      src="https://npmcdn.com/regl/dist/regl.min.js"
      type="text/javascript"
    ></script>
  </head>
  <body style="font-family: sans-serif">
    <div
      id="chart-container"
      style="position: relative; flex-shrink: 0; width: 800px; height: 800px"
    >
      <canvas
        id="content"
        style="position: absolute; top: 0; left: 0; width: 100%; height: 100%"
      ></canvas>
    </div>
    <button id="animate-button">Animate</button>
    <div id="results"></div>
    <script type="module">
      import * as counterpoint from 'https://cdn.jsdelivr.net/npm/counterpoint-vis@latest/dist/counterpoint-vis.es.js';

      // Declare the chart dimensions and margins.
      let width = 2;
      let height = 2;
      let canvas = document.getElementById('content');
      canvas.width = canvas.offsetWidth * window.devicePixelRatio;
      canvas.height = canvas.offsetHeight * window.devicePixelRatio;

      const numPointArray = [100, 1000, 5000, 10000, 50000, 100000];
      const urlParams = new URLSearchParams(window.location.search);
      const numPoints = parseInt(urlParams.get('points'));
      const numPointIndex = numPointArray.indexOf(numPoints);
      const swapFraction = 0.25;
      const maxDelta = 0.2;
      const pointSize = 4;
      let numTrials = 0;

      function randomID() {
        var text = '';

        var charset = 'abcdefghijklmnopqrstuvwxyz0123456789';

        for (var i = 0; i < 20; i++)
          text += charset.charAt(Math.floor(Math.random() * charset.length));

        return text;
      }

      let randomDelta = () => Math.random() * maxDelta - maxDelta * 0.5;

      // initialize the render group with 100 marks
      let marks = new counterpoint.MarkRenderGroup(
        new Array(numPoints).fill(0).map(
          (i) =>
            new counterpoint.Mark(randomID(), {
              x: Math.random() * width - width * 0.5,
              y: Math.random() * height - height * 0.5,
              alpha: 1.0,
            })
        )
      )
        .configure({ animationDuration: 5000 })
        .configureStaging({
          initialize: (mark) => mark.setAttr('alpha', 0.0),
          enter: (mark) => mark.animateTo('alpha', 1.0).wait('alpha'),
          exit: (mark) => mark.animateTo('alpha', 0.0).wait('alpha'),
        })
        .registerPreloadableProperty('x')
        .registerPreloadableProperty('y')
        .registerPreloadableProperty('alpha');

      function animate() {
        // remove swapFraction elements at random
        let numToSwap = Math.floor(numPoints * swapFraction);
        let ids = marks.getMarks().map((m) => m.id);
        for (let i = 0; i < numToSwap; i++) {
          let randomMark = Math.floor(Math.random() * ids.length);
          marks.delete(ids[randomMark]);
          ids.splice(randomMark, 1);
        }

        // move existing marks
        marks.animateTo('x', (m) => m.attr('x') + randomDelta());
        marks.animateTo('y', (m) => m.attr('y') + randomDelta());

        // add swapFraction more
        for (let i = 0; i < numToSwap; i++) {
          let randomMark = new counterpoint.Mark(randomID(), {
            x: Math.random() * width - width * 0.5,
            y: Math.random() * height - width * 0.5,
            alpha: 0.0,
          });
          marks.addMark(randomMark);
        }

        profile();
        marks.wait('x').then(() => {
          stopProfile = true;
          if (numTrials < 19) {
            numTrials++;
            setTimeout(animate, 5000);
          } else {
            setTimeout(() => {
              let text = document
                .getElementById('results')
                .innerText.replace('\n\n', '\n');
              var element = document.createElement('a');
              element.setAttribute(
                'href',
                'data:text/plain;charset=utf-8,' + encodeURIComponent(text)
              );
              element.setAttribute('download', `cp_regl_${numPoints}.txt`);

              element.style.display = 'none';
              document.body.appendChild(element);

              element.click();

              document.body.removeChild(element);

              if (numPointIndex < numPointArray.length - 1)
                setTimeout(() => {
                  window.location.href =
                    window.location.href.slice(
                      0,
                      window.location.href.length -
                        window.location.search.length
                    ) + `?points=${numPointArray[numPointIndex + 1]}`;
                }, 5000);
            }, 1000);
          }
        });
      }

      // Animate button event handler
      document
        .getElementById('animate-button')
        .addEventListener('click', animate);

      let regl = createREGL(canvas);
      // we will only update these buffers when the preload attributes change
      let maxPoints = marks.count() + Math.floor(numPoints * swapFraction);
      let bufferCount = marks.count();
      let xBuffer = regl.buffer(maxPoints * 4);
      let yBuffer = regl.buffer(maxPoints * 4);
      let alphaBuffer = regl.buffer(maxPoints * 4);

      let drawDots = regl({
        frag: `
        precision mediump float;
        uniform vec4 color;
        varying float fAlpha;

        void main () {
          vec2 cxy = 2.0 * gl_PointCoord - 1.0;
          if (dot(cxy, cxy) > 0.8) {
            discard;
          }
          gl_FragColor = vec4(color.xyz, color.w * fAlpha);
        }`,

        vert: `
        precision mediump float;
        attribute vec4 x;
        attribute vec4 y;
        attribute vec4 alpha;
        uniform float currentTime;
        uniform float radius;
        varying float fAlpha;

        void animate(in vec4 attrib, out float interpolatedValue) {
          float t = clamp(
            (attrib.w - attrib.z >= 0.001) ? (currentTime - attrib.z) / (attrib.w - attrib.z) : 0.0,
            0.0,
            1.0
          );
          t = t * t * (3.0 - 2.0 * t);
          interpolatedValue = attrib.y * t + attrib.x * (1.0 - t);
        }

        void main () {
          gl_PointSize = radius * 2.0;
          float finalX, finalY;
          animate(x, finalX);
          animate(y, finalY);
          animate(alpha, fAlpha);
          gl_Position = vec4(finalX, finalY, 0, 1);
        }`,

        attributes: {
          x: xBuffer,
          y: yBuffer,
          alpha: alphaBuffer,
        },
        uniforms: {
          color: [0.1, 0.25, 0.98, 1.0],
          radius: regl.prop('radius'),
          currentTime: regl.prop('currentTime'),
        },
        count: regl.prop('count'),
        primitive: 'points',
        blend: {
          enable: true,
          func: {
            srcRGB: 'src alpha',
            srcAlpha: 'src alpha',
            dstRGB: 'one minus src alpha',
            dstAlpha: 'one minus src alpha',
          },
        },
        depth: {
          enable: false,
        },
      });

      // Clear and redraw every frame
      regl.frame(() => {
        regl.clear({
          color: [1.0, 1.0, 1.0, 1.0],
          depth: 1,
        });
        drawDots({
          radius: pointSize,
          currentTime: marks.currentTime(),
          count: bufferCount,
        });
      });

      function updateBuffers() {
        if (!canvas || !regl) return;

        let currentMarks = marks.stage.getVisibleMarks();
        bufferCount = currentMarks.length;
        xBuffer(
          currentMarks
            .map((mark) => {
              let x = mark.attributes['x'].getPreload();
              return [x.start, x.end, x.startTime, x.endTime];
            })
            .flat()
        );
        yBuffer(
          currentMarks
            .map((mark) => {
              let y = mark.attributes['y'].getPreload();
              return [y.start, y.end, y.startTime, y.endTime];
            })
            .flat()
        );
        alphaBuffer(
          currentMarks
            .map((mark) => {
              let alpha = mark.attributes['alpha'].getPreload();
              return [alpha.start, alpha.end, alpha.startTime, alpha.endTime];
            })
            .flat()
        );
      }

      let ticker = new counterpoint.Ticker(marks).onChange(updateBuffers);
      updateBuffers();

      let stopProfile = false;
      function profile() {
        stopProfile = false;
        let currentTime = window.performance.now();
        let totalFrameDurations = 0;
        let totalFrames = 0;
        function frame() {
          totalFrameDurations += window.performance.now() - currentTime;
          totalFrames++;
          currentTime = window.performance.now();
          if (!stopProfile) requestAnimationFrame(frame);
          else {
            document.getElementById(
              'results'
            ).innerHTML += `<p>cp_regl,${numPoints},${totalFrames},${
              totalFrameDurations / totalFrames
            }</p>`;
          }
        }

        requestAnimationFrame(frame);
      }

      setTimeout(animate);
    </script>
  </body>
</html>
